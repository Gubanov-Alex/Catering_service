"""
STATUSES: not started, cooking, cooked, finished

BUENO HTTP POST /
```
    order: [
        {
            dish: string
            quantity: number
        }, ...      
    ]
```
RESPONSE:
```
    {
        id: string,  // generated by restaurant
        status: string
    }
```


WEBHOOK HTTP POST <SELECT>
```
    {
        id: string,
        status: string
    }
```

=================================================================

STATUS: not started, cooking, cooked, finished

MELANGE HTTP POST /api/orders
```
    order: [
        {
            dish: string
            quantity: number
        }, ...      
    ]
```
```
    {
        id: string,
        status: string
    }
```

MELANGE HTTP GET /api/orders/<ID>
```
    {
        status: string
    }
```
"""

from collections import defaultdict
from datetime import datetime, date, time
import json
from time import sleep
import uuid

import httpx
from shared.cache import CacheService
from .models import DishOrderItem, Order, OrderExternalIDRestaurant
from .enums import Restaurant
from config import celery_app




class OrderInCache:
    """
    {
        "bueno"|"melange": {
            "external_id": string,
            "status": string,
            "dishes": [
                {
                    "dish": string,
                    "quantity": number,
                }, ...
            ]
        }
    }
    """

    def __init__(self) -> None:
        self.orders: dict[str, dict[str, str | list[dict]]] = defaultdict(dict)

    def append(self, restaurant: str, item: DishOrderItem):
        if not self.orders[restaurant]:
            self.orders[restaurant] = {
                "external_id": "",
                "status": "not_started",
                "dishes": [
                    {
                        "dish": item.dish.name,
                        "quantity": item.quantity,
                    }
                ],
            }
        else:
            self.orders[restaurant]["dishes"].append(
                {
                    "dish": item.dish.name,
                    "quantity": item.quantity,
                }
            )


# todo: uncomment
# @celery_app.task
def melange_order_processing(order: OrderInCache, order_instance=None):
    external_record = OrderExternalIDRestaurant.objects.get(
        order=order_instance, restaurant=Restaurant.MELANGE
    )

    while external_record.status != "finished":
        if external_record.status == "not_started":
            if not external_record.external_id:
                payload = {"order": order.orders[Restaurant.MELANGE]["dishes"]}
                response = httpx.post("http://localhost:8001/api/orders", json=payload)
                response.raise_for_status()

                # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ external_id Ð¸Ð· Ð¾Ñ‚Ð²ÐµÑ‚Ð°
                external_record.external_id = response.json()["id"]
                external_record.save()
            else:
                response = httpx.get(f"http://localhost:8001/api/orders/{external_record.external_id}")
                response.raise_for_status()

                external_record.status = response.json()["status"]
                external_record.save()
                print(f"Current status for MELANGE: {external_record.status}. Waiting 1 second")
                sleep(1)

        elif external_record.status == "cooking":
            response = httpx.get(f"http://localhost:8001/api/orders/{external_record.external_id}")
            response.raise_for_status()
            external_record.status = response.json()["status"]
            external_record.save()
            print(f"Current status for MELANGE: {external_record.status}. Waiting 3 seconds")
            sleep(3)

        elif external_record.status == "cooked":
            print(f"ðŸšš CALLING DELIVERY SERVICE TO PASS THE FOOD ORDER")
            external_record.status = "finished"
            external_record.save()
            print(f"Order {external_record.external_id} is delivered")

        else:
            raise ValueError(f"Status {external_record.status} is not supported")


# def bueno_order_processing(order: OrderInCache):
#     print("BUENO===============================")
#     print(order.orders)
#     print("BUENO===============================")

# todo: uncomment
# @celery_app.task
def bueno_order_processing(order: OrderInCache, order_instance=None):
    external_record = OrderExternalIDRestaurant.objects.filter(
        order=order_instance, restaurant=Restaurant.BUENO
    ).first()

    while external_record.status != "finished":
        if external_record.status == "not_started":
            if not external_record.external_id:
                payload = {"order": order.orders[Restaurant.BUENO]["dishes"]}
                response = httpx.post("http://localhost:8002", json=payload)
                response.raise_for_status()

                external_record.external_id = response.json()["id"]
                external_record.save()
            else:
                response = httpx.get(f"http://localhost:8002/{external_record.external_id}")
                response.raise_for_status()

                external_record.status = response.json()["status"]
                external_record.save()
                print(f"Current status for BUENO: {external_record.status}. Waiting 1 second")
                sleep(1)

        elif external_record.status == "cooking":
            response = httpx.get(f"http://localhost:8002/{external_record.external_id}")
            response.raise_for_status()
            external_record.status = response.json()["status"]
            external_record.save()
            print(f"Current status for BUENO: {external_record.status}. Waiting 3 seconds")
            sleep(3)

        elif external_record.status == "cooked":
            print(f"ðŸšš CALLING DELIVERY SERVICE TO PASS THE FOOD ORDER")
            external_record.status = "finished"
            external_record.save()
            print(f"Order {external_record.external_id} is delivered")

        else:
            raise ValueError(f"Status {external_record.status} is not supported")


# todo: uncomment
# @celery_app.task
def _schedule_order(order: Order):
    """Start processing restaurants orders.

    Workflow:
    1. Create temporary orders.
    2. Form intermediate order data in the cache.
    3. Call restaurants' APIs and handle responses.
    4. Process the orders in the background.
    """
    order_in_cache = OrderInCache()

    for item in order.items.all():
        restaurant_name = item.dish.restaurant.name.lower()
        if restaurant_name == Restaurant.MELANGE:
            order_in_cache.append(Restaurant.MELANGE, item)
        elif restaurant_name == Restaurant.BUENO:
            order_in_cache.append(Restaurant.BUENO, item)
        else:
            raise ValueError(
                f"Cannot create order for {item.dish.restaurant.name} restaurant"
            )

    order_key = str(uuid.uuid4())
    cache = CacheService()

    cache.set(
        namespace="restaurants_order", key=order_key, instance=order_in_cache.orders
    )

    for restaurant, data in order_in_cache.orders.items():
        OrderExternalIDRestaurant.objects.create(
            order=order,
            restaurant=restaurant,
            external_id="",
            status=data["status"],
        )

    if Restaurant.MELANGE in order_in_cache.orders:
        melange_order_processing(order_in_cache, order_instance=order)

    if Restaurant.BUENO in order_in_cache.orders:
        bueno_order_processing(order_in_cache, order_instance=order)


def schedule_order(order: Order):
    """Add the task to the queue for the future processing."""

    assert type(order.eta) is date

    # todo: remove
    _schedule_order(order)
    return None

    # 2025-03-06  -> 2025-03-06-00:00:00 UTC
    if order.eta == date.today():
        print(f"The order will be started processing now")
        return schedule_order_task.delay(order)
    else:
        # ETA: 3:00AM will be sent to restaurant APIs
        eta = datetime.combine(order.eta, time(hour=3))
        print(f"The order will be started processing {eta}")
        return schedule_order_task.apply_async(args=(order,), eta=eta)