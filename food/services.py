"""
STATUSES: not started, cooking, cooked, finished

BUENO HTTP POST /
```
    order: [
        {
            dish: string
            quantity: number
        }, ...      
    ]
```
RESPONSE:
```
    {
        id: string,  // generated by restaurant
        status: string
    }
```


WEBHOOK HTTP POST <SELECT>
```
    {
        id: string,
        status: string
    }
```

=================================================================

STATUS: not started, cooking, cooked, finished

MELANGE HTTP POST /api/orders
```
    order: [
        {
            dish: string
            quantity: number
        }, ...      
    ]
```
```
    {
        id: string,
        status: string
    }
```

MELANGE HTTP GET /api/orders/<ID>
```
    {
        status: string
    }
```
"""

from collections import defaultdict
from datetime import datetime, date, time
import json
from time import sleep
import uuid

import httpx
from shared.cache import CacheService
from .models import DishOrderItem, Order, RestaurantOrderID
from .enums import Restaurant
from config import celery_app




class OrderInCache:
    """
    {
        "bueno"|"melange": {
            "external_id": string,
            "status": string,
            "dishes": [
                {
                    "dish": string,
                    "quantity": number,
                }, ...
            ]
        }
    }
    """

    def __init__(self) -> None:
        self.orders: dict[str, dict[str, str | list[dict]]] = defaultdict(dict)

    def append(self, restaurant: str, item: DishOrderItem):
        if not self.orders[restaurant]:
            self.orders[restaurant] = {
                "external_id": "",
                "status": "not_started",
                "dishes": [
                    {
                        "dish": item.dish.name,
                        "quantity": item.quantity,
                    }
                ],
            }
        else:
            self.orders[restaurant]["dishes"].append(
                {
                    "dish": item.dish.name,
                    "quantity": item.quantity,
                }
            )


def update_order_status_if_needed(order_instance: Order):
    """Check if all restaurant orders have the same status and update main order."""
    restaurant_orders = RestaurantOrderID.objects.filter(order=order_instance)
    unique_statuses = set(restaurant_orders.values_list('status', flat=True))

    if len(unique_statuses) == 1:
        common_status = unique_statuses.pop()
        order_instance.status = common_status
        order_instance.save()
        print(f"Order {order_instance.id} status updated to {common_status}")


# todo: uncomment
# @celery_app.task
def melange_order_processing(order: OrderInCache, order_instance=None):
    restaurant_orders = RestaurantOrderID.objects.get(
        order=order_instance, restaurant=Restaurant.MELANGE
    )

    while restaurant_orders.status != "finished":
        if restaurant_orders.status == "not_started":
            if not restaurant_orders.external_id:
                payload = {"order": order.orders[Restaurant.MELANGE]["dishes"]}
                response = httpx.post("http://localhost:8001/api/orders", json=payload)
                response.raise_for_status()
                restaurant_orders.external_id = response.json()["id"]
                restaurant_orders.save()

            else:
                response = httpx.get(f"http://localhost:8001/api/orders/{restaurant_orders.external_id}")
                response.raise_for_status()
                restaurant_orders.status = response.json()["status"]
                restaurant_orders.save()
                update_order_status_if_needed(order_instance)
                print(f"Current status for MELANGE: {restaurant_orders.status}. Waiting 1 second")
                sleep(1)

        elif restaurant_orders.status == "cooking":
            response = httpx.get(f"http://localhost:8001/api/orders/{restaurant_orders.external_id}")
            response.raise_for_status()
            restaurant_orders.status = response.json()["status"]
            restaurant_orders.save()
            update_order_status_if_needed(order_instance)
            print(f"Current status for MELANGE: {restaurant_orders.status}. Waiting 3 seconds")
            sleep(3)

        elif restaurant_orders.status == "cooked":
            print(f"ðŸšš CALLING DELIVERY SERVICE TO PASS THE FOOD ORDER")
            restaurant_orders.status = "finished"
            restaurant_orders.save()
            update_order_status_if_needed(order_instance)
            print(f"Order {restaurant_orders.external_id} is delivered")

        else:
            raise ValueError(f"Status {restaurant_orders.status} is not supported")



# def bueno_order_processing(order: OrderInCache):
#     print("BUENO===============================")
#     print(order.orders)
#     print("BUENO===============================")

# todo: uncomment
# @celery_app.task
def bueno_order_processing(order: OrderInCache, order_instance=None):
    restaurant_orders = RestaurantOrderID.objects.filter(
        order=order_instance, restaurant=Restaurant.BUENO
    ).first()

    while restaurant_orders.status != "finished":
        if restaurant_orders.status == "not_started":
            if not restaurant_orders.external_id:
                payload = {"order": order.orders[Restaurant.BUENO]["dishes"]}
                response = httpx.post("http://localhost:8002", json=payload)
                response.raise_for_status()
                restaurant_orders.external_id = response.json()["id"]
                restaurant_orders.save()

            else:
                response = httpx.get(f"http://localhost:8002/{restaurant_orders.external_id}")
                response.raise_for_status()
                restaurant_orders.status = response.json()["status"]
                restaurant_orders.save()
                update_order_status_if_needed(order_instance)
                print(f"Current status for BUENO: {restaurant_orders.status}. Waiting 1 second")
                sleep(1)

        elif restaurant_orders.status == "cooking":
            response = httpx.get(f"http://localhost:8002/{restaurant_orders.external_id}")
            response.raise_for_status()
            restaurant_orders.status = response.json()["status"]
            restaurant_orders.save()
            update_order_status_if_needed(order_instance)  # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ ÑÑ‚Ð°Ñ‚ÑƒÑÑ‹
            print(f"Current status for BUENO: {restaurant_orders.status}. Waiting 3 seconds")
            sleep(3)

        elif restaurant_orders.status == "cooked":
            print(f"ðŸšš CALLING DELIVERY SERVICE TO PASS THE FOOD ORDER")
            restaurant_orders.status = "finished"
            restaurant_orders.save()
            update_order_status_if_needed(order_instance)
            print(f"Order {restaurant_orders.external_id} is delivered")

        else:
            raise ValueError(f"Status {restaurant_orders.status} is not supported")



# todo: uncomment
# @celery_app.task
def _schedule_order(order: Order):
    """Start processing restaurants orders.

    Workflow:
    1. Create temporary orders.
    2. Form intermediate order data in the cache.
    3. Call restaurants' APIs and handle responses.
    4. Process the orders in the background.
    """
    order_in_cache = OrderInCache()

    for item in order.items.all():
        restaurant_name = item.dish.restaurant.name.lower()
        if restaurant_name == Restaurant.MELANGE:
            order_in_cache.append(Restaurant.MELANGE, item)
        elif restaurant_name == Restaurant.BUENO:
            order_in_cache.append(Restaurant.BUENO, item)
        else:
            raise ValueError(
                f"Cannot create order for {item.dish.restaurant.name} restaurant"
            )

    order_key = str(uuid.uuid4())
    cache = CacheService()

    cache.set(
        namespace="restaurants_order", key=order_key, instance=order_in_cache.orders
    )

    for restaurant, data in order_in_cache.orders.items():
        RestaurantOrderID.objects.create(
            order=order,
            restaurant=restaurant,
            external_id="",
            status=data["status"],
        )

    if Restaurant.MELANGE in order_in_cache.orders:
        melange_order_processing(order_in_cache, order_instance=order)

    if Restaurant.BUENO in order_in_cache.orders:
        bueno_order_processing(order_in_cache, order_instance=order)


def schedule_order(order: Order):
    """Add the task to the queue for the future processing."""

    assert type(order.eta) is date

    # todo: remove
    _schedule_order(order)
    return None

    # 2025-03-06  -> 2025-03-06-00:00:00 UTC
    if order.eta == date.today():
        print(f"The order will be started processing now")
        return schedule_order_task.delay(order)
    else:
        # ETA: 3:00AM will be sent to restaurant APIs
        eta = datetime.combine(order.eta, time(hour=3))
        print(f"The order will be started processing {eta}")
        return schedule_order_task.apply_async(args=(order,), eta=eta)